
/*
 *
 * VCF parser
 *
 *
 *
 * [[ MSPRIME SIMULATED VCF INPUT ]]
 * generated by tskit.write_vcf()
 *
 *
 * ** [POSITIONS]
 * Positions are 0-based
 * in contrast to regular vcf specs=1-based
 *
 * ** [ALLELES]
 * * REF(=ANC)=0
 * Reference allele is the same as ancestral allele
 * Encoded as 0
 * * ALT=1
 * Only one ALT allele is present
 * Encoded as 1
 * 
 *
 * [GL order in VCF format]
 *
 * for P=ploidy and N=number of alternate alleles;
 * for a_p in 0:N; for a_p-1 in 0:a_p; print(a1,a2);
 *
 * For P=2 N=3
 *
 * 0,1,2,3
 * A,C,G,T
 * 00,01,11,02,12,22,03,13,23,33
 * AA,AC,CC,AG,CG,GG,AT,CT,GT,TT
 *
 *
 * ** GLF
 * A, C, G, T
 *
 */

#include <stdio.h>
#include <htslib/vcf.h>
#include <htslib/vcfutils.h>

#include <inttypes.h>
#include <math.h>

#include <time.h>

#include "random_generator.h"
#include "estimator.h"
#include "io.h"


const int vcf_gl_order_idx[10]={0,1,4,2,5,7,3,6,8,9};

//TODO depth=0 sites



FILE *getFILE(const char*fname,const char* mode){
	FILE *fp;
	if(NULL==(fp=fopen(fname,mode))){
		fprintf(stderr,"[%s:%s()]\t->Error opening FILE handle for file:%s exiting\n",__FILE__,__FUNCTION__,fname);
		exit(0);
	}
	return fp;
}



FILE *openFile(const char* a,const char* b){
	char *c = (char*)malloc(strlen(a)+strlen(b)+1);
	strcpy(c,a);
	strcat(c,b);
	// fprintf(stderr,"\t-> Dumping file: %s\n",c);
	FILE *fp = getFILE(c,"w");
	free(c);
	return fp;
}



int pick_base(double errate, int inbase){
	int outbase;
	if (drand48()<errate){
		while ((outbase=(floor(4*drand48()))) == inbase);
		return outbase;
	}
	else return inbase;
}


int main(int argc, char **argv) {


	if(argc==1){
		fprintf(stderr,"\n\nhelp\n\n");
		return 0;
	}
	argStruct *args=args_get(--argc,++argv);

	if(args!=NULL){

		char *in_fn=args->in_fn;
		char *out_fp=args->out_fp;
		double errate=args->errate;
		double mps_depth=args->mps_depth;
		int isSim=args->isSim;

		FILE *arg_ff=openFile(out_fp,".arg");

		fprintf(arg_ff,"-in %s -out %s -err %f -depth %f -isSim %d -seed %d\n",args->in_fn,args->out_fp,args->errate,args->mps_depth,args->isSim,args->seed);

		int n_sim_reads;

		vcfFile * in_ff = bcf_open(in_fn, "r");


		char *out_fn = (char*)malloc(strlen(out_fp)+5);

		strcpy(out_fn,out_fp);
		strcat(out_fn,".vcf");
		vcfFile * out_ff = bcf_open(out_fn, "w");

		if (in_ff == NULL) {
			return 1;
		}

		if (bcf == 0) {
			return 1; 
		}

		bcf_hdr_t *hdr = bcf_hdr_read(in_ff);

		bcf_hdr_t *out_hdr = bcf_hdr_dup(hdr);
		bcf_hdr_merge(out_hdr,hdr);


		// bcf_hdr_append(out_hdr, "##FORMAT=<ID=DP,Number=1,Type=Float,Description=\"Read Depth\">");

		//TODO add source tag for this program

		if(bcf_hdr_append(out_hdr, "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Simulated read depth\">")!=0){
			fprintf(stderr,"failed to append header\n");
			exit(1);
		}

		if(bcf_hdr_append(out_hdr, "##FORMAT=<ID=GL,Number=G,Type=Float,Description=\"Genotype likelihood in log10 likelihood ratio format\">")!=0){
			fprintf(stderr,"failed to append header\n");
			exit(1);
		}

		if(bcf_hdr_write(out_ff,out_hdr)!=0){
			fprintf(stderr,"failed to write bcf\n");
			exit(1);
		}

		bcf1_t *bcf = bcf_init();



		int nSites=0; 



		if(isSim){
			fprintf(stderr, "\n -isSim=%d ; will shift coord sys+1\n", isSim);
		}

		int nSamples=bcf_hdr_nsamples(hdr);


		fprintf(stderr, "\nReading file:\t\"%s\"\n", in_fn);
		// fprintf(stderr, "Number of samples: %i\n", bcf_hdr_nsamples(hdr));
		// fprintf(stderr,	"Number of chromosomes: %d\n",hdr->n[BCF_DT_CTG]);
		//
		// fprintf(stderr, "\n\n\n");
		//

		//TODO 3->10
		//AA,AC,CC,AG,CG,GG,AT,CT,GT,TT
		//


		float *gl_vals  =   (float*)malloc(10*nSamples*sizeof(float));
		int32_t *dp_vals  =   (int32_t*)malloc(10*nSamples*sizeof(int32_t));

		bcf1_t *out_bcf;

		//TODO test the use of tsk_0 vs tsk0 err as explained in tskit doc,if it affects us

		//todo >= use? was it binary
		while (bcf_read(in_ff, hdr, bcf) == 0) {


			out_bcf=bcf_dup(bcf);



			//TODO unpack?
			// bcf_unpack(bcf,BCF_UN_FMT);
			// bcf_unpack(bcf, BCF_UN_ALL);
			// bcf_unpack(bcf, BCF_UN_INFO);



			// bcf_fmt_t *gt = bcf_get_fmt(hdr, bcf, "GT");
			int32_t *gt_arr=NULL;
			int32_t ngt_arr=0;
			int ngt=bcf_get_genotypes(hdr, bcf, &gt_arr, &ngt_arr);
			if ( ngt<=0 ){
				fprintf(stderr,"\nGT not present\n");
			}

			int gt_ploidy=ngt/nSamples;


			int sample_i;


			for (sample_i=0; sample_i<nSamples; sample_i++) {


				n_sim_reads=Poisson(mps_depth);

				if(n_sim_reads==0){

					for(int j=0;j<10;j++){
						//TODO check blw
						bcf_float_set_missing(gl_vals[sample_i*10+j]);
					}
					dp_vals[sample_i]=0;

				}else{

					// fprintf(stderr,"\nn_sim_reads: %d\n",n_sim_reads);

					int32_t *ptr = gt_arr + sample_i*gt_ploidy;

					if (gt_ploidy!=2){
						fprintf(stderr,"ERROR:\n\nploidy: %d not supported\n",gt_ploidy);
						return 1;
					}

					int bin_gts[2] = {0,0};

					double like[10]={-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0};

					//binary input genotypes from simulated input
					for (int i=0; i<gt_ploidy;i++){
						bin_gts[i]= bcf_gt_allele(ptr[i]);
					}

					// fprintf(stderr,"%d (%d,%d)\n",n_sim_reads,bin_gts[0],bin_gts[1]);

					for (int i=0; i<n_sim_reads; i++){
						if(drand48()<0.5){
							gl_log10(pick_base(errate,bin_gts[0]), errate, like);
						}else{
							gl_log10(pick_base(errate,bin_gts[1]), errate, like);
						}
					}


#if 0
					fprintf(stderr, "\n");
					fprintf(stderr, "like(");
					for(int i=0;i<10;i++){
						if (i) {fprintf(stderr, ",");}
						fprintf(stderr, "%f",like[i]);
					}
					fprintf(stderr, ")");
					fprintf(stderr, "\n");
#endif
					rescale_likelihood_ratio(like);


					for(int j=0;j<10;j++){
						//TODO check blw
						// gl_vals[sample_i+j]=like[vcf_gl_order_idx[j]];
						gl_vals[sample_i*10+j]=like[vcf_gl_order_idx[j]];
					}

					dp_vals[sample_i]=n_sim_reads;

				}

				out_bcf->pos=bcf->pos+isSim;

			} //end sample loop


			bcf_update_format_int32(out_hdr, out_bcf, "DP", dp_vals,nSamples);

			// update ref, alt
			if(bcf_update_alleles_str(out_hdr,out_bcf,"A,C,G,T")!=0){
				fprintf(stderr,"Error: Failed to update\n");
				exit(1);
			}


			bcf_update_format_float(out_hdr, out_bcf, "GL", gl_vals,10*nSamples);

			// bcf_write(out_ff, hdr, out_bcf);
			if(bcf_write(out_ff, out_hdr, out_bcf)!=0){
				fprintf(stderr,"Error: Failed to write\n");
				exit(1);
			}

			nSites++;

			free(gt_arr);

		}




		fprintf(stderr, "Total number of sites: %i\n", nSites);

		bcf_hdr_destroy(hdr);
		bcf_destroy(bcf);
		bcf_hdr_destroy(out_hdr);
		bcf_destroy(out_bcf);

		int BCF_CLOSE;
		if ( (BCF_CLOSE=bcf_close(in_ff))){
			fprintf(stderr,"bcf_close(%s): non-zero status %d\n",in_fn,BCF_CLOSE);
			exit(BCF_CLOSE);
		}

		if ( (BCF_CLOSE=bcf_close(out_ff)) ){
			fprintf(stderr,"bcf_close(%s): non-zero status %d\n",out_fn,BCF_CLOSE);
			exit(BCF_CLOSE);
		}else{
			fprintf(stderr,"\nDumping output to file: %s\n\n",out_fn);

		}

		free(out_fn);
		free(args->in_fn);
		free(args->out_fp);
		free(args);

		free(gl_vals);



	}

	return 0;

}
