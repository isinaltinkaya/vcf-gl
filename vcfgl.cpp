
/*
 *
 *
 *
 * [[ MSPRIME SIMULATED VCF INPUT ]]
 * generated by tskit.write_vcf()
 *
 *
 * ** [POSITIONS]
 * Positions are 0-based
 * in contrast to regular vcf specs=1-based
 *
 * ** [ALLELES]
 * * REF(=ANC)=0
 * Reference allele is the same as ancestral allele
 * Encoded as 0
 * * ALT=1
 * Only one ALT allele is present
 * Encoded as 1
 * 
 *
 * [GL order in VCF format]
 *
 * for P=ploidy and N=number of alternate alleles;
 * for a_p in 0:N; for a_p-1 in 0:a_p; print(a1,a2);
 *
 * For P=2 N=3
 *
 * 0,1,2,3
 * A,C,G,T
 * 00,01,11,02,12,22,03,13,23,33
 * AA,AC,CC,AG,CG,GG,AT,CT,GT,TT
 *
 *
 * ** GLF
 * A, C, G, T
 *
 */

#include <stdio.h>
#include <htslib/vcf.h>
#include <htslib/vcfutils.h>

#include <inttypes.h>
#include <math.h>
#include <time.h>

#include "random_generator.h"
#include "estimator.h"
#include "io.h"

#include "version.h"
#include "from_htslib.h"
#include "shared.h"

const int vcf_gl_order_idx[10]={0,1,4,2,5,7,3,6,8,9};

typedef struct
{
	int type;
	const char *str, *hdr;
}
tag_t;
enum tag{ GP, GL, PL, GT, QS, I16, DP};
tag_t tags[] =
{
	[GP]   = { .type = BCF_HT_REAL, 
		.str = "GP", 
		.hdr = "##FORMAT=<ID=GP,Number=G,Type=Float,Description=\"Genotype probabilities\">" 
	},
	[GL]   = { .type = BCF_HT_REAL, 
		.str = "GL", 
		.hdr = "##FORMAT=<ID=GL,Number=G,Type=Float,Description=\"Genotype likelihood in log10 likelihood ratio format\">"
	},
	[PL]   = { .type = BCF_HT_INT,  
		.str = "PL", 
		.hdr = "##FORMAT=<ID=PL,Number=G,Type=Integer,Description=\"Phred-scaled genotype likelihoods\">" 
	},
	[GT]   = { .type = BCF_HT_STR,  
		.str = "GT", 
		.hdr = "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">" 
	},
	[QS]   = { .type = BCF_HT_INT,
		.str = "QS",
		.hdr = "##FORMAT=<ID=QS,Number=R,Type=Integer,Description=\"Phred-score allele quality sum. Auxiliary tag used for calling\">" 
	},
	[I16]   = { .type = BCF_HT_REAL, 
		.str = "I16", 
		.hdr = "##INFO=<ID=I16,Number=16,Type=Float,Description=\"Auxiliary tag used for calling, see description of bcf_callret1_t in bam2bcf.h\">"
	},
	[DP]    = { .type = BCF_HT_INT,
		.str = "DP",
		.hdr = "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Simulated read depth\">"
	},

};


int sample_strand(){
	int i=rand() % 2;
	return(i);
}


int sample_tail_length(){
	int i=sample_uniform_from_range(1,50);
	return(i);
}


FILE *getFILE(const char*fname,const char* mode){
	FILE *fp;
	if(NULL==(fp=fopen(fname,mode))){
		fprintf(stderr,"[%s:%s()]\t->Error opening FILE handle for file:%s exiting\n",__FILE__,__FUNCTION__,fname);
		exit(0);
	}
	return fp;
}



FILE *openFile(const char* a,const char* b){
	char *c = (char*)malloc(strlen(a)+strlen(b)+1);
	strcpy(c,a);
	strcat(c,b);
	// fprintf(stderr,"\t-> Dumping file: %s\n",c);
	FILE *fp = getFILE(c,"w");
	free(c);
	return fp;
}



int pick_base(double errate, int inbase){
	int outbase;
	if (drand48()<errate){
		while ((outbase=(floor(4*drand48()))) == inbase);
		return outbase;
	}
	else return inbase;
}


char *get_time(){
	time_t current_time;
	struct tm *local_time; 
	current_time=time(NULL);
	local_time=localtime(&current_time);
	return(asctime(local_time));
}

int32_t *gt_arr=NULL;


int setblank(bcf1_t *blk,bcf1_t *unmod,bcf_hdr_t *hdr){

	int32_t ngt_arr=0;
	int ngt=bcf_get_genotypes(hdr, blk, &gt_arr, &ngt_arr);
	if ( ngt<=0 ){
		fprintf(stderr,"\nGT not present\n");
	}

	int32_t *tmpia = gt_arr;
	for(int i=0; i<bcf_hdr_nsamples(hdr);i++){
		tmpia[2*i+0] = bcf_gt_phased(0);
		tmpia[2*i+1] = bcf_gt_phased(0);
	}
	bcf_update_genotypes(hdr, blk, tmpia, bcf_hdr_nsamples(hdr)*2); 

	return 0;
}


int simulate_record(bcf_hdr_t *out_hdr,bcf1_t *out_bcf_rec,int nSamples,double* mps_depths, argStruct* args, const int site_i, FILE* out_baseCounts_ff){

	int n=10*nSamples;

	float *gl_vals=(float*)malloc(n*sizeof(float));
	int32_t *dp_vals=(int32_t*)malloc(n*sizeof(int32_t));

	float* gp_vals=NULL;
	if(1==args->addGP){
		gp_vals=(float*)malloc(n*sizeof(float));
	}

	int32_t *pl_vals=NULL;
	if(1==args->addPL){
		pl_vals=(int32_t*) malloc(n*sizeof(float));
	}

	int n_sim_reads;  
	int32_t ngt_arr=0;
	int ngt=bcf_get_genotypes(out_hdr, out_bcf_rec, &gt_arr, &ngt_arr);
	if ( ngt<=0 ){
		fprintf(stderr,"\nGT not present\n");
	}

	int gt_ploidy=ngt/nSamples;



	int acgt_counts[4]={0};

	for (int sample_i=0; sample_i<nSamples; sample_i++) {

		if(args->printBaseCounts==1){
			acgt_counts[4]={0};
		}


		if(mps_depths!=NULL){
			n_sim_reads=Poisson(mps_depths[sample_i]);
		}else{
			n_sim_reads=Poisson(args->mps_depth);
		}


		if(n_sim_reads==0){

			for(int j=0;j<10;j++){
				bcf_float_set_missing(gl_vals[sample_i*10+j]);
				// bcf_float_set_missing(gp_vals[sample_i*10+j]);
				if ( bcf_float_is_vector_end(gl_vals[sample_i*10+j]) ) {
					NEVER;
					ASSERT(0==1);
				}
			}
			dp_vals[sample_i]=0;

		}else{

			int32_t *ptr = gt_arr + sample_i*gt_ploidy;

			if (gt_ploidy!=2){
				fprintf(stderr,"ERROR:\n\nploidy: %d not supported\n",gt_ploidy);
				return 1;
			}

			int bin_gts[2] = {0,0};

			double like[10]={-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0};

			//binary input genotypes from simulated input
			for (int i=0; i<gt_ploidy;i++){
				bin_gts[i]= bcf_gt_allele(ptr[i]);
				// use bit shifting to check if bin_gt[n] is 0 or 1
				if( (bin_gts[i] >> 1) != 0){
					fprintf(stderr,"ERROR:\n\nbin_gts[%d]: Genotype %d not supported.\n",i,bin_gts[i]);
					exit(1);
				}
			}


			int base=0;
			for (int i=0; i<n_sim_reads; i++){
				if(drand48()<0.5){
					base=pick_base(args->errate,bin_gts[0]), args->errate, like;
					acgt_counts[base]++;
					gl_log10(base,args->errate,like);
				}else{
					base=pick_base(args->errate,bin_gts[1]);
					gl_log10(base,args->errate,like);
					acgt_counts[base]++;
				}
			}

#if 0
			fprintf(stderr, "\n");
			fprintf(stderr, "like(");
			for(int i=0;i<10;i++){
				if (i) {fprintf(stderr, ",");}
				fprintf(stderr, "%f",like[i]);
			}
			fprintf(stderr, ")");
			fprintf(stderr, "\n");
#endif
			rescale_likelihood_ratio(like);


			for(int j=0;j<10;j++){
				gl_vals[sample_i*10+j]=like[vcf_gl_order_idx[j]];
			}

			dp_vals[sample_i]=n_sim_reads;

		}


		if(args->printBaseCounts==1){
			fprintf(out_baseCounts_ff,"%d\t%d\t%d\t%d\t%d\t%d\n",site_i,sample_i,acgt_counts[0],acgt_counts[1],acgt_counts[2],acgt_counts[3]);
		}


	} //end sample loop


	bcf_update_format_int32(out_hdr, out_bcf_rec, "DP", dp_vals,nSamples);

	// update ref, alt
	if(bcf_update_alleles_str(out_hdr,out_bcf_rec,"A,C,G,T")!=0){
		fprintf(stderr,"Error: Failed to update\n");
		exit(1);
	}


	bcf_update_format_float(out_hdr, out_bcf_rec, "GL", gl_vals,n);


	/// @@@@@@@@@@@


	if(1==args->addPL){

		// int miarr=-1;
		// hts_expand(int32_t, n, miarr, pl_vals);
		for (int i=0; i<n; i++)
		{
			if ( bcf_float_is_missing(gl_vals[i]) ) pl_vals[i] = bcf_int32_missing;
			else if ( bcf_float_is_vector_end(gl_vals[i]) ) pl_vals[i] = bcf_int32_vector_end;
			else pl_vals[i] = lroundf(-10*gl_vals[i]);
		}
		bcf_update_format_int32(out_hdr,out_bcf_rec,"PL",pl_vals,n);

		free(pl_vals);
		pl_vals=NULL;
	}


	/// @@@@@@@@@@@

	if(1==args->addGP){
		for (int i=0; i<nSamples; i++)
		{
			float *gpp = gp_vals+ i*10;
			float *glp = gl_vals+ i*10;
			float sum = 0;
			for (int j=0; j<10; j++)
			{
				if ( bcf_float_is_vector_end(glp[j]) ) {
					NEVER;// we never expect to truncate the vector and finish early
				}
				if ( bcf_float_is_missing(glp[j]) ) {
					bcf_float_set_missing(gpp[j]);
					continue;
				}else{
					gpp[j]=glp[j];
				}
				gpp[j] = pow(10, gpp[j]);
				sum += gpp[j];
			}
			if ( sum<=0 ) continue;
			for (int j=0; j<10; j++)
			{
				if ( bcf_float_is_missing(gpp[j]) ) {
					continue;
				}
				if ( bcf_float_is_vector_end(gpp[j]) ) {
					NEVER;
					// break;
				}

				gpp[j] /= sum;
			}
		}
		bcf_update_format_float(out_hdr,out_bcf_rec,"GP",gp_vals,n);
		free(gp_vals);
		gp_vals=NULL;
	}




	free(gl_vals);
	gl_vals=NULL;
	free(dp_vals);
	dp_vals=NULL;



	return 0;
}


int main(int argc, char **argv) {


	if(argc==1){
		fprintf(stderr,"\n");
		fprintf(stderr,"vcfgl\n\n");
		fprintf(stderr,"\tUsage: ./vcfgl -in <input> [options]\n\n");
		fprintf(stderr,"\t -in <input>\t\t\tinput\n");
		fprintf(stderr,"\n");
		fprintf(stderr,"Options:\n");
		fprintf(stderr,"\t-out <prefix>\t\t\toutput prefix\n");
		fprintf(stderr,"\t-O <mode>\t\t\toutput mode\n");
		fprintf(stderr,"\t-mode <mode>\t\t\toutput mode\n");
		fprintf(stderr,"\t-depth <depth>\t\t\tdepth\n");
		fprintf(stderr,"\t-df <depths_file>\t\t\tdepths file\n");
		fprintf(stderr,"\t-err <error_rate>\t\terror rate\n");
		fprintf(stderr,"\t-seed <seed>\t\t\tseed\n");
		fprintf(stderr,"\t-explode [0|1] <explode>\texplode\n");
		fprintf(stderr,"\t-pos0 [0|1] <pos0>\t\tpos0\n");

		return 0;
	}
	argStruct *args=args_get(--argc,++argv);

	if(args!=NULL){

		char *in_fn=args->in_fn;
		char *out_fp=args->out_fp;
		char* in_mps_depths=args->in_mps_depths;
		double *mps_depths=NULL;
		double mps_depth=args->mps_depth;
		int pos0=args->pos0;

		FILE *arg_ff=openFile(out_fp,".arg");

		FILE *out_baseCounts_ff=NULL;
		if(args->printBaseCounts==1){
			out_baseCounts_ff=openFile(out_fp,".baseCounts.tsv");
			fprintf(out_baseCounts_ff,"site\tind\tA\tC\tG\tT\n");
		}

		fprintf(stderr,"\n-in %s -out %s -err %f -depth %f -depths_file %s -pos0 %d -seed %d -mode %s -explode %d\n",args->in_fn,args->out_fp,args->errate,args->mps_depth,args->in_mps_depths,args->pos0,args->seed,args->output_mode,args->explode);
		fprintf(arg_ff,"\n-in %s -out %s -err %f -depth %f -depths_file %s -pos0 %d -seed %d -mode %s -explode %d\n",args->in_fn,args->out_fp,args->errate,args->mps_depth,args->in_mps_depths,args->pos0,args->seed,args->output_mode,args->explode);


		vcfFile * in_ff = bcf_open(in_fn, "r");
		vcfFile * out_ff;

		char *OUT_EXT;
		char *out_fn=NULL;
		switch (*args->output_mode){
			case 'v':
				fprintf(stderr,"\nOutput is VCF file\n");
				OUT_EXT=strdup(".vcf");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "w");
				break;
			case 'b':
				fprintf(stderr,"\nOutput is BCF file\n");
				OUT_EXT=strdup(".bcf");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "wb");
				break;
			case 'z':
				fprintf(stderr,"\nOutput is compressed VCF file\n");
				OUT_EXT=strdup(".vcf.gz");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "wz");
				break;
			case 'u':
				fprintf(stderr,"\nOutput is uncompressed BCF file\n");
				OUT_EXT=strdup(".bcf");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "wbu");
				break;
		}
		free(OUT_EXT);

		if (in_ff == NULL) {
			return 1;
		}

		if (bcf == 0) {
			return 1; 
		}



		bcf_hdr_t *hdr = bcf_hdr_read(in_ff);

		bcf_hdr_t *out_hdr = bcf_hdr_dup(hdr);
		bcf_hdr_merge(out_hdr,hdr);


		char *DATE_TAG;
		char *DATETIME=get_time();
		fprintf(stderr,"\n%s\n",DATETIME);

		if(asprintf(&DATE_TAG, "##fileDate=%s", DATETIME)>0){

			if(bcf_hdr_append(out_hdr, DATE_TAG)!=0){
				fprintf(stderr,"failed to append header\n");
				exit(1);
			}
			free(DATE_TAG);
		}else{
			exit(1);
		}
		char *SOURCE_TAG;

		if(asprintf(&SOURCE_TAG, "##source=vcfgl -err %f -depth %f -df %s -pos0 %d -seed %d -explode %d",args->errate,args->mps_depth,args->in_mps_depths, args->pos0,args->seed, args->explode)>0){

			if(bcf_hdr_append(out_hdr, SOURCE_TAG)!=0){
				fprintf(stderr,"failed to append header\n");
				exit(1);
			}
			free(SOURCE_TAG);
		}else{
			exit(1);
		}

		char *SOURCE_VERSION_TAG;
		if(asprintf(&SOURCE_VERSION_TAG, "##source=vcfgl version: %s",VCFGL_VERSION)>0){
			if(bcf_hdr_append(out_hdr, SOURCE_VERSION_TAG)!=0){
				fprintf(stderr,"failed to append header\n");
				exit(1);
			}
			free(SOURCE_VERSION_TAG);
		}else{
			exit(1);
		}

		ASSERT(bcf_hdr_append(out_hdr,tags[GL].hdr)==0);
		ASSERT(bcf_hdr_append(out_hdr,tags[GP].hdr)==0);
		ASSERT(bcf_hdr_append(out_hdr,tags[PL].hdr)==0);

		ASSERT(bcf_hdr_append(out_hdr,tags[DP].hdr)==0);

		ASSERT(bcf_hdr_write(out_ff,out_hdr)==0);

		bcf1_t *bcf = bcf_init();
		int nSites=0;



		if(pos0){
			fprintf(stderr, "\n -pos0=%d ; This means input VCF's positions are 0 based, and will shift coordinate system with +1\n", pos0);
		}

		int nSamples=bcf_hdr_nsamples(hdr);


		if(in_mps_depths!=NULL){
			mps_depths=read_depthsFile(in_mps_depths, nSamples);

			fprintf(stderr, "\n");
			for (int sample_i=0; sample_i<nSamples; sample_i++) {
				fprintf(stderr, "Individual %d mean per-site depth is set to %f\n", sample_i,mps_depths[sample_i]);
			}
		}


		fprintf(stderr, "\nReading file:\t\"%s\"\n", in_fn);
		fprintf(stderr, "Number of samples: %i\n", bcf_hdr_nsamples(hdr));
		fprintf(stderr,	"Number of contigs: %d\n",hdr->n[BCF_DT_CTG]);


		bcf1_t *out_bcf_rec=bcf_init();
		bcf1_t *blank = bcf_init();;

		while (bcf_read(in_ff, hdr, bcf) == 0) {
			//copy next record with data into out_bcf_rec
			out_bcf_rec=bcf_copy(out_bcf_rec,bcf);
			if(args->explode==0){
				simulate_record(out_hdr,out_bcf_rec,nSamples,mps_depths,args,nSites,out_baseCounts_ff);
				if(out_bcf_rec->pos==-1){
					if(pos0==0){
						fprintf(stderr,"\n[ERROR]: Input file coordinates start from 0; but -pos0 is not set to 1. Please run again with -pos0 1.\n\n");
						exit(1);
					}
				}
				out_bcf_rec->pos += pos0;
				if(bcf_write(out_ff, out_hdr, out_bcf_rec)!=0){
					fprintf(stderr,"Error: Failed to write\n");
					exit(1);
				}
				nSites++;
			}else{
				//ensure that we have a empty blank record that we can modify
				blank = bcf_copy(blank,out_bcf_rec);

				if(out_bcf_rec->pos==-1){
					if(pos0==0){
						fprintf(stderr,"\n[ERROR]: Input file coordinates start from 0; but -pos0 is not set to 1. Please run again with -pos0 1.\n\n");
						exit(1);
					}
				}

				while(1){//this block should run for every site with missing/nodata
						 //  fprintf(stderr,"\t\t-> out_bcf_recpos: %d nSites: %d\n",out_bcf_rec->pos,nSites);
					if(nSites==out_bcf_rec->pos+pos0){
						// fprintf(stderr,"now breaking\n");
						break;
					}

					setblank(blank,out_bcf_rec,hdr);
					simulate_record(out_hdr,blank,nSamples,mps_depths,args,nSites,out_baseCounts_ff);
					blank->pos = nSites;
					// fprintf(stderr,"blank->pos: %d\n",blank->pos+pos0);
					if(bcf_write(out_ff, out_hdr, blank)!=0){
						fprintf(stderr,"Error: Failed to write\n");
						exit(1);
					}
					nSites++;

				}
				// fprintf(stderr,"After loop that fills in missing data will print out: %d\n",out_bcf_rec->pos+pos0+1);
				simulate_record(out_hdr,out_bcf_rec,nSamples,mps_depths,args,nSites,out_baseCounts_ff);
				out_bcf_rec->pos += pos0;
				if(bcf_write(out_ff, out_hdr, out_bcf_rec)!=0){
					fprintf(stderr,"Error: Failed to write\n");
					exit(1);
				}
				nSites++;
			}
		}
		if(args->explode==1){
			//		fprintf(stderr,	"Number of contigs: %d\n",hdr->n[BCF_DT_CTG]);
			bcf_idpair_t *ctg = ctg = hdr->id[BCF_DT_CTG];
			int contigsize = ctg[out_bcf_rec->rid].val->info[0];
			// fprintf(stderr,"contigsize: %d\n",contigsize);

			while(nSites<contigsize){
				setblank(blank,out_bcf_rec,hdr);
				simulate_record(out_hdr,blank,nSamples,mps_depths,args,nSites,out_baseCounts_ff);
				blank->pos = nSites;
				if(bcf_write(out_ff, out_hdr, blank)!=0){
					fprintf(stderr,"Error: Failed to write\n");
					exit(1);
				}
				nSites++;
			}
		}



		fprintf(stderr, "Total number of sites: %i\n", nSites);

		bcf_hdr_destroy(hdr);
		bcf_destroy(bcf);
		bcf_hdr_destroy(out_hdr);
		bcf_destroy(out_bcf_rec);
		bcf_destroy(blank);

		int BCF_CLOSE;
		if ( (BCF_CLOSE=bcf_close(in_ff))){
			fprintf(stderr,"bcf_close(%s): non-zero status %d\n",in_fn,BCF_CLOSE);
			exit(BCF_CLOSE);
		}

		if ( (BCF_CLOSE=bcf_close(out_ff)) ){
			fprintf(stderr,"bcf_close(%s): non-zero status %d\n",out_fn,BCF_CLOSE);
			exit(BCF_CLOSE);
		}else{
			fprintf(stderr,"\nDumping output to file: %s\n\n",out_fn);
		}

		if(fclose(arg_ff)!=0){
			fprintf(stderr,"Error closing file");
			exit(1);
		}


		if(args->printBaseCounts==1){
			if(fclose(out_baseCounts_ff)!=0){
				fprintf(stderr,"Error closing file");
				exit(1);
			}else{
				fprintf(stderr,"\nDumping baseCounts file to %s.baseCounts.tsv\n",out_fp);
			}
		}

		args_destroy(args);

		free(out_fn);
		free(gt_arr);

	}

	return 0;

}
